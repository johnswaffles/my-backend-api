<!-- Squarespace Code Block Start -->
<!-- Version: 2024-11-29-v2-PremiumUI -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400;600&display=swap"
    rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<div id="storyforge-app">
    <!-- Background Elements -->
    <div class="sf-bg-glow"></div>

    <!-- Header -->
    <header class="sf-header glass-panel">
        <div class="sf-brand">
            <div class="sf-logo">‚ú®</div>
            <div class="sf-title">StoryForge</div>
        </div>
        <div class="sf-controls">
            <select id="genre-selector" class="sf-select" title="Select Genre">
                <option value="High Fantasy" selected>üêâ High Fantasy</option>
                <option value="Dark Fantasy">üåë Dark Fantasy</option>
                <option value="Sci-Fi Space Opera">üöÄ Sci-Fi</option>
                <option value="Cyberpunk">ü¶æ Cyberpunk</option>
                <option value="Noir Mystery">üïµÔ∏è Noir Mystery</option>
                <option value="Gothic Horror">üè∞ Gothic Horror</option>
                <option value="Western">ü§† Western</option>
                <option value="Modern Thriller">üèôÔ∏è Thriller</option>
                <option value="Romance">üíñ Romance</option>
                <option value="Superhero">ü¶∏ Superhero</option>
                <option value="Comedy">üòÇ Comedy</option>
                <option value="Video Game">üéÆ Video Game</option>
                <option value="Christian">‚úùÔ∏è Christian</option>
            </select>
            <select id="voice-selector" class="sf-select" title="Select Voice">
                <option value="">üîá Silent</option>
                <option value="dPah2VEoifKnZT37774q" selected>üéôÔ∏è Thorne</option>
                <option value="MFZUKuGQUsGJPQjTS4wC">üéôÔ∏è Caleb</option>
                <option value="ZthjuvLPty3kTMaNKVKb">üéôÔ∏è Elijah</option>
                <option value="NOpBlnGInO9m6vDvFkFC">üéôÔ∏è Grandpa</option>
                <option value="fCxG8OHm4STbIsWe4aT9">üéôÔ∏è Marcus</option>
                <option value="MSFwcDuw9rcnKKFbmBqn">üéôÔ∏è Johnny</option>
                <option value="Z3R5wn05IrDiVCyEkUrK">üéôÔ∏è Sophia</option>
                <option value="iP95p4xoKVk53GoZ742B">üéôÔ∏è Gabriel</option>
            </select>
            <button id="play-pause-btn" class="sf-btn-icon" disabled title="Play/Pause TTS">‚ñ∂Ô∏è</button>
            <button id="download-btn" class="sf-btn-icon" disabled title="Download Audio">üíæ</button>
        </div>
    </header>

    <!-- Main Chat Area -->
    <main id="chat-container">
        <div id="chat-messages">
            <div class="message bot-message">
                <div class="avatar">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2L14.5 9.5L22 12L14.5 14.5L12 22L9.5 14.5L2 12L9.5 9.5L12 2Z" fill="url(#grad1)" />
                        <defs>
                            <linearGradient id="grad1" x1="2" y1="2" x2="22" y2="22" gradientUnits="userSpaceOnUse">
                                <stop stop-color="#ffd700" />
                                <stop offset="1" stop-color="#b537f2" />
                            </linearGradient>
                        </defs>
                    </svg>
                </div>
                <div class="message-content">
                    Welcome, traveler. Select a genre and voice above, then tell me how your story begins...
                </div>
            </div>
        </div>
    </main>

    <!-- Inventory Panel -->
    <div id="inventory-panel" class="glass-panel">
        <div class="panel-label">INVENTORY</div>
        <div id="inventory-grid">
            <div class="empty-slot">Empty</div>
        </div>
        <select id="item-use-dropdown" class="sf-select-sm">
            <option value="">‚öóÔ∏è Use Item</option>
        </select>
    </div>

    <!-- Input Area -->
    <footer class="sf-footer glass-panel">
        <input type="text" id="chat-input" placeholder="What do you do next?" autocomplete="off">
        <button id="send-btn" class="sf-btn-primary">SEND</button>
    </footer>
</div>

<style>
    :root {
        --bg-dark: #0f0c29;
        --bg-mid: #302b63;
        --bg-light: #24243e;
        --accent-gold: #ffd700;
        --accent-purple: #b537f2;
        --text-main: #ffffff;
        --text-muted: #a0a0a0;
        --glass-bg: rgba(20, 20, 40, 0.7);
        --glass-border: rgba(255, 255, 255, 0.1);
        --font-header: 'Cinzel', serif;
        --font-body: 'Inter', sans-serif;
    }

    /* Reset & Base */
    #storyforge-app * {
        box-sizing: border-box;
    }

    #storyforge-app {
        font-family: var(--font-body);
        background: linear-gradient(135deg, var(--bg-dark), var(--bg-mid));
        color: var(--text-main);
        width: 100%;
        max-width: 900px;
        height: 700px;
        margin: 0 auto;
        border-radius: 16px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        position: relative;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
        border: 1px solid var(--glass-border);
    }

    /* Background Glow */
    .sf-bg-glow {
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(181, 55, 242, 0.1) 0%, transparent 60%);
        pointer-events: none;
        z-index: 0;
    }

    /* Glassmorphism Utility */
    .glass-panel {
        background: var(--glass-bg);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid var(--glass-border);
        z-index: 10;
    }

    /* Header */
    .sf-header {
        padding: 16px 24px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--glass-border);
    }

    .sf-brand {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .sf-logo {
        font-size: 1.5rem;
        animation: float 3s ease-in-out infinite;
    }

    .sf-title {
        font-family: var(--font-header);
        font-size: 1.4rem;
        font-weight: 700;
        background: linear-gradient(to right, #fff, var(--accent-gold));
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: 1px;
    }

    .sf-controls {
        display: flex;
        gap: 10px;
    }

    /* Controls */
    .sf-select {
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid var(--glass-border);
        color: var(--text-main);
        padding: 6px 12px;
        border-radius: 8px;
        font-family: var(--font-body);
        font-size: 0.85rem;
        cursor: pointer;
        transition: all 0.2s;
    }

    .sf-select:hover {
        border-color: var(--accent-purple);
    }

    .sf-btn-icon {
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid var(--glass-border);
        color: var(--text-main);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
    }

    .sf-btn-icon:hover:not(:disabled) {
        background: var(--accent-purple);
        transform: scale(1.05);
    }

    .sf-btn-icon:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    /* Chat Area */
    #chat-container {
        flex: 1;
        overflow-y: auto;
        padding: 24px;
        position: relative;
        z-index: 5;
        scroll-behavior: smooth;
    }

    #chat-messages {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    /* Messages */
    .message {
        display: flex;
        gap: 12px;
        max-width: 85%;
        animation: fadeUp 0.4s ease-out forwards;
        opacity: 0;
        transform: translateY(10px);
    }

    .bot-message {
        align-self: flex-start;
    }

    .user-message {
        align-self: flex-end;
        flex-direction: row-reverse;
    }

    .avatar {
        width: 36px;
        height: 36px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        border: 1px solid var(--glass-border);
        flex-shrink: 0;
    }

    .message-content {
        padding: 14px 18px;
        border-radius: 12px;
        line-height: 1.6;
        font-size: 0.95rem;
        position: relative;
    }

    .bot-message .message-content {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid var(--glass-border);
        border-top-left-radius: 2px;
    }

    .user-message .message-content {
        background: linear-gradient(135deg, var(--accent-purple), #8a2be2);
        color: white;
        border-top-right-radius: 2px;
        box-shadow: 0 4px 15px rgba(181, 55, 242, 0.3);
    }

    .message-body {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-width: 0;
        /* Prevent flex overflow */
    }

    /* Message Download Button */
    .message-download-container {
        margin-top: 8px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        padding-top: 8px;
        display: flex;
        justify-content: flex-end;
        width: 100%;
    }

    .message-download-btn {
        background: rgba(255, 215, 0, 0.1);
        border: 1px solid var(--accent-gold);
        color: var(--accent-gold);
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s;
        white-space: nowrap;
    }

    .message-download-btn:hover {
        background: var(--accent-gold);
        color: var(--bg-dark);
    }

    /* Loading Spinner for Play Button */
    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-top: 2px solid white;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        display: inline-block;
    }

    /* Inventory */
    #inventory-panel {
        padding: 12px 24px;
        display: flex;
        align-items: center;
        gap: 16px;
        border-top: 1px solid var(--glass-border);
    }

    .panel-label {
        font-family: var(--font-header);
        font-size: 0.8rem;
        color: var(--accent-gold);
        letter-spacing: 1px;
    }

    #inventory-grid {
        flex: 1;
        display: flex;
        gap: 8px;
        overflow-x: auto;
        padding-bottom: 4px;
    }

    .inventory-item {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid var(--accent-gold);
        padding: 4px 10px;
        border-radius: 4px;
        font-size: 0.8rem;
        white-space: nowrap;
        color: var(--accent-gold);
    }

    .empty-slot {
        color: var(--text-muted);
        font-style: italic;
        font-size: 0.8rem;
    }

    .sf-select-sm {
        padding: 4px 8px;
        font-size: 0.8rem;
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid var(--glass-border);
        color: var(--text-main);
        border-radius: 4px;
    }

    /* Footer */
    .sf-footer {
        padding: 20px 24px;
        display: flex;
        gap: 12px;
    }

    #chat-input {
        flex: 1;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid var(--glass-border);
        padding: 14px;
        border-radius: 8px;
        color: white;
        font-family: var(--font-body);
        font-size: 1rem;
        transition: all 0.2s;
    }

    #chat-input:focus {
        outline: none;
        border-color: var(--accent-purple);
        background: rgba(0, 0, 0, 0.5);
    }

    .sf-btn-primary {
        background: var(--accent-purple);
        color: white;
        border: none;
        padding: 0 24px;
        border-radius: 8px;
        font-family: var(--font-header);
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        letter-spacing: 1px;
    }

    .sf-btn-primary:hover:not(:disabled) {
        background: #d05bf5;
        box-shadow: 0 0 15px rgba(208, 91, 245, 0.4);
    }

    .sf-btn-primary:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    /* Animations */
    @keyframes fadeUp {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* ========================================
       MOBILE RESPONSIVE STYLES
       ======================================== */

    @media (max-width: 768px) {

        /* App Container */
        #storyforge-app {
            height: 100vh;
            max-width: 100%;
            border-radius: 0;
            margin: 0;
        }

        /* Header - Stack controls on small screens */
        .sf-header {
            padding: 12px 16px;
            flex-direction: column;
            gap: 12px;
            align-items: stretch;
        }

        .sf-brand {
            justify-content: center;
        }

        .sf-title {
            font-size: 1.2rem;
        }

        .sf-logo {
            font-size: 1.3rem;
        }

        .sf-controls {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            width: 100%;
        }

        .sf-select {
            font-size: 0.8rem;
            padding: 8px;
            min-width: 0;
        }

        .sf-btn-icon {
            width: 40px;
            height: 40px;
        }

        /* Chat Area - More padding */
        #chat-container {
            padding: 16px;
        }

        /* Messages - Better mobile spacing */
        .message {
            max-width: 95%;
            gap: 8px;
        }

        .message-content {
            font-size: 0.95rem;
            line-height: 1.6;
            padding: 12px 14px;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .avatar {
            width: 32px;
            height: 32px;
            min-width: 32px;
            /* Prevent shrinking */
        }

        /* Inventory - Full width on mobile */
        #inventory-panel {
            position: relative;
            right: auto;
            bottom: auto;
            width: 100%;
            margin: 0;
            border-radius: 0;
            padding: 12px 16px;
        }

        #inventory-grid {
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 8px;
        }

        .item-slot,
        .empty-slot {
            padding: 8px;
            font-size: 0.75rem;
        }

        /* Footer - Better button sizing */
        .sf-footer {
            padding: 12px 16px;
            gap: 10px;
        }

        #chat-input {
            font-size: 1rem;
            /* Prevent zoom on iOS */
            padding: 12px;
        }

        #send-btn {
            padding: 12px 20px;
            font-size: 0.9rem;
            min-width: 80px;
            white-space: nowrap;
        }

        /* Loader - Smaller on mobile */
        .sf-loader {
            width: 40px;
            height: 40px;
        }

        /* Prevent text overflow */
        .message-content p {
            margin: 0.5em 0;
        }

        .message-content ul,
        .message-content ol {
            padding-left: 1.5em;
            margin: 0.5em 0;
        }
    }

    /* Extra small phones */
    @media (max-width: 375px) {
        .sf-title {
            font-size: 1rem;
        }

        .sf-controls {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto;
        }

        .sf-btn-icon {
            grid-column: 1 / -1;
            justify-self: center;
            width: 100%;
            max-width: 120px;
            border-radius: 8px;
        }

        .message-content {
            font-size: 0.9rem;
        }

        #send-btn {
            min-width: 70px;
            padding: 12px 16px;
        }
    }


    @keyframes float {

        0%,
        100% {
            transform: translateY(0);
        }

        50% {
            transform: translateY(-5px);
        }
    }

    @keyframes pulse-glow {
        0% {
            box-shadow: 0 0 5px var(--accent-purple);
        }

        50% {
            box-shadow: 0 0 20px var(--accent-purple), 0 0 10px var(--accent-gold);
        }

        100% {
            box-shadow: 0 0 5px var(--accent-purple);
        }
    }

    /* Magical Loader */
    .magical-orb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #fff, var(--accent-purple));
        animation: pulse-glow 1.5s infinite ease-in-out;
        margin: 0 auto;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
    }

    ::-webkit-scrollbar-track {
        background: transparent;
    }

    ::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.4);
    }

    /* Mobile */
    @media (max-width: 600px) {
        #storyforge-app {
            height: 100vh;
            border-radius: 0;
        }

        .sf-title {
            display: none;
        }
    }
</style>

<script>
    (function () {
        if (window.storyForgeInitialized) return;
        window.storyForgeInitialized = true;

        const BACKEND_URL = 'https://my-backend-api-1niy.onrender.com';

        // --- Audio Queue System ---
        class AudioQueue {
            constructor() {
                this.queue = [];
                this.isPlaying = false;
                this.currentAudio = null;
            }

            add(item) {
                this.queue.push(item);
                if (!this.isPlaying) this.playNext();
            }

            playNext() {
                if (this.queue.length === 0) {
                    this.isPlaying = false;
                    updatePlayButton(false);
                    return;
                }

                this.isPlaying = true;
                const item = this.queue.shift();

                let url;
                if (typeof item === 'string') {
                    url = item; // It's a URL
                } else {
                    url = URL.createObjectURL(item); // It's a Blob
                }

                this.currentAudio = new Audio();
                this.currentAudio.crossOrigin = "anonymous"; // Re-added for reliable CORS handling
                this.currentAudio.src = url;
                this.currentAudio.preload = "auto";

                this.currentAudio.preload = "auto";

                updatePlayButton('loading');

                this.currentAudio.onwaiting = () => updatePlayButton('loading');
                this.currentAudio.onplaying = () => updatePlayButton('playing');
                this.currentAudio.onpause = () => updatePlayButton('paused');

                this.currentAudio.onended = () => {
                    if (typeof item !== 'string') URL.revokeObjectURL(url); // Clean up blob URLs
                    this.playNext();
                };

                this.currentAudio.onerror = (e) => {
                    console.error("Audio Playback Error", e);
                    addMessage(`‚ö†Ô∏è Playback Error: ${e.type}`, false, true);
                    if (typeof item !== 'string') URL.revokeObjectURL(url);
                    this.playNext();
                };

                // Attempt to play
                const playPromise = this.currentAudio.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.error("Playback failed", error);
                        // Auto-play might be blocked. Show a "Click to Play" message or just stop.
                        // But since user clicked "Send", it should work.
                        // Unless the async fetch took too long?
                        updatePlayButton(false);
                    });
                }
            }

            stop() {
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio = null;
                }
                this.queue = [];
                this.isPlaying = false;
                updatePlayButton(false);
            }

            pause() {
                if (this.currentAudio) {
                    this.currentAudio.pause();
                }
                this.isPlaying = false;
                updatePlayButton(false);
            }
        }

        const audioQueue = new AudioQueue();

        // --- State & DOM ---
        const state = {
            inventory: [],
            history: [],
            lastFullText: '',
            christianContext: false,
            romanceContext: false,
            videoGameContext: false,
            audioCache: null,  // Cache audio to prevent duplicate API calls
            userChangedVoice: false  // Track if user manually changed voice
        };

        const els = {
            input: document.getElementById('chat-input'),
            sendBtn: document.getElementById('send-btn'),
            messages: document.getElementById('chat-messages'),
            genre: document.getElementById('genre-selector'),
            voice: document.getElementById('voice-selector'),
            playPause: document.getElementById('play-pause-btn'),
            downloadBtn: document.getElementById('download-btn'),
            invGrid: document.getElementById('inventory-grid'),
            itemDrop: document.getElementById('item-use-dropdown'),
            container: document.getElementById('chat-container')
        };

        // --- Helpers ---

        function stripAudioTags(text) {
            // Remove all audio tags like [whispers], [laughs], [pause], etc.
            return text.replace(/\[([a-z_]+)\]/gi, '');
        }

        function updatePlayButton(state) {
            // Backward compatibility for boolean
            if (typeof state === 'boolean') {
                state = state ? 'playing' : 'paused';
            }

            if (state === 'loading') {
                els.playPause.innerHTML = '<div class="spinner"></div>';
                els.playPause.title = "Buffering...";
            } else if (state === 'playing') {
                els.playPause.innerHTML = '‚è∏Ô∏è';
                els.playPause.title = "Pause";
            } else {
                els.playPause.innerHTML = '‚ñ∂Ô∏è';
                els.playPause.title = "Play";
            }
        }

        function splitText(text) {
            // Split into [First Chunk, Rest]
            // Goal: Grab first ~50 words or ~300 chars to ensure audio buffer is long enough
            // Look for punctuation after 250 chars
            if (text.length < 300) {
                return { first: text, rest: '' };
            }

            const splitIdx = text.indexOf('.', 250);
            if (splitIdx !== -1) {
                return {
                    first: text.substring(0, splitIdx + 1),
                    rest: text.substring(splitIdx + 1)
                };
            }

            // Fallback if no punctuation found reasonably early
            return { first: text, rest: '' };
        }

        async function fetchTTS(text) {
            try {
                // Clean text for TTS: remove *actions*, emojis, and JSON objects
                // This prevents the voice from reading "smiles" or "open brace action..."
                const cleanText = text
                    .replace(/\*[^*]+\*/g, '') // Remove *text*
                    .replace(/\{.*?\}/g, '')   // Remove {JSON} objects (fix for jibberish)
                    .replace(/[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}]/gu, '') // Remove emojis
                    .trim();

                if (!cleanText) return null; // Nothing to say

                // Show loading spinner on play button
                const originalBtnContent = els.playPause.innerHTML;
                els.playPause.innerHTML = '<div class="spinner"></div>';
                els.playPause.disabled = true;

                // Optimization: Use GET endpoint for streaming if text is short enough
                // This allows the browser to stream the audio directly via Audio element
                // Increased limit to 4000 chars to cover most stories
                if (cleanText.length < 4000) {
                    const url = `${BACKEND_URL}/tts?text=${encodeURIComponent(cleanText)}&voice=${els.voice.value}`;

                    // Restore button content immediately as we return the URL
                    els.playPause.innerHTML = originalBtnContent;
                    return url;
                }

                // Fallback to POST for long text (waits for full download)
                const response = await fetch(`${BACKEND_URL}/tts`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: cleanText,
                        voice: els.voice.value
                    })
                });

                // Restore button content
                els.playPause.innerHTML = originalBtnContent;

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`ElevenLabs API Error: ${response.status} ${JSON.stringify(errorData)}`);
                }

                const blob = await response.blob();
                return blob;
            } catch (error) {
                console.error('TTS Fetch Error:', error);
                addMessage(`‚ö†Ô∏è TTS Error: ${error.message}`, false, true);
                els.playPause.innerHTML = '‚ñ∂Ô∏è'; // Restore play icon on error
                els.playPause.disabled = true;
                return null;
            }
        }

        // --- UI Functions ---

        function addMessage(text, isUser, isError = false, audioBlob = null) {
            const div = document.createElement('div');
            div.className = `message ${isUser ? 'user-message' : 'bot-message'}`;

            // Avatar
            if (!isUser) {
                const avatar = document.createElement('div');
                avatar.className = 'avatar';
                if (isError) {
                    avatar.textContent = '‚ö†Ô∏è';
                } else {
                    // Cool SVG Graphic (Sparkle/Star)
                    avatar.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2L14.5 9.5L22 12L14.5 14.5L12 22L9.5 14.5L2 12L9.5 9.5L12 2Z" fill="url(#grad1)"/>
                        <defs>
                            <linearGradient id="grad1" x1="2" y1="2" x2="22" y2="22" gradientUnits="userSpaceOnUse">
                                <stop stop-color="#ffd700"/>
                                <stop offset="1" stop-color="#b537f2"/>
                            </linearGradient>
                        </defs>
                    </svg>`;
                }
                div.appendChild(avatar);
            }

            // Message Body Wrapper (Text + Download Button)
            const messageBody = document.createElement('div');
            messageBody.className = 'message-body';

            const content = document.createElement('div');
            content.className = 'message-content';

            if (isUser || isError) {
                content.textContent = text;
            } else {
                content.innerHTML = marked.parse(text);
            }

            messageBody.appendChild(content);

            // Add download button for bot messages with audio
            if (!isUser && !isError && audioBlob) {
                const downloadContainer = document.createElement('div');
                downloadContainer.className = 'message-download-container';

                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'message-download-btn';
                downloadBtn.innerHTML = 'üíæ Download Audio';
                downloadBtn.title = 'Download Audio';
                downloadBtn.onclick = async () => {
                    const originalText = downloadBtn.innerHTML;
                    downloadBtn.innerHTML = '‚è≥ Downloading...';
                    downloadBtn.disabled = true;

                    try {
                        let blob;
                        if (typeof audioBlob === 'string') {
                            const resp = await fetch(audioBlob);
                            if (!resp.ok) throw new Error('Download failed');
                            blob = await resp.blob();
                        } else {
                            blob = audioBlob;
                        }

                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `storyforge-${Date.now()}.mp3`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        console.error("Download error", e);
                        alert("Failed to download audio.");
                    } finally {
                        downloadBtn.innerHTML = originalText;
                        downloadBtn.disabled = false;
                    }
                };

                downloadContainer.appendChild(downloadBtn);
                messageBody.appendChild(downloadContainer);
            }

            div.appendChild(messageBody);
            els.messages.appendChild(div);

            // Scroll
            setTimeout(() => {
                els.container.scrollTop = els.container.scrollHeight;
            }, 50);
        }

        function updateInventory() {
            // Hide inventory for Christian genre
            if (els.genre.value === 'Christian') {
                els.invGrid.innerHTML = '<div class="empty-slot">Inventory disabled in this mode</div>';
                els.itemDrop.innerHTML = '<option value="">‚öóÔ∏è Inventory Disabled</option>';
                els.itemDrop.disabled = true;
                return;
            }

            els.itemDrop.disabled = false;

            if (state.inventory.length === 0) {
                els.invGrid.innerHTML = '<div class="empty-slot">Empty</div>';
                els.itemDrop.innerHTML = '<option value="">‚öóÔ∏è Use Item</option>';
                return;
            }

            els.invGrid.innerHTML = state.inventory.map(item =>
                `<div class="inventory-item" title="${item.description || ''}">${item.name}</div>`
            ).join('');

            els.itemDrop.innerHTML = '<option value="">‚öóÔ∏è Use Item</option>';
            state.inventory.forEach((item, idx) => {
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = `Use ${item.name}`;
                els.itemDrop.appendChild(opt);
            });
        }

        // --- Core Logic ---

        // Function to parse and apply actions from bot reply
        function parseAndApplyActions(replyText) {
            const lines = replyText.split('\n');
            const cleanLines = lines.filter(line => {
                if (line.trim().startsWith('{') && line.trim().endsWith('}')) {
                    try {
                        const action = JSON.parse(line);
                        if (action.action === 'add_item') state.inventory.push(action.item);
                        if (action.action === 'remove_item') {
                            state.inventory = state.inventory.filter(i => i.name !== action.item.name);
                        }
                        if (action.action === 'consume_item') {
                            state.inventory = state.inventory.filter(i => i.name !== action.item.name);
                            addMessage(`‚ú® Used ${action.item.name}`, false);
                        }
                        return false; // This line was an action, so filter it out of the display text
                    } catch (e) {
                        console.warn("Failed to parse action JSON:", line, e);
                        return true; // Keep line if it looks like JSON but fails to parse
                    }
                }
                return true; // Keep non-JSON lines
            });
            updateInventory(); // Update inventory after processing actions
            return cleanLines.join('\n').trim(); // Return the text without action lines
        }



        async function sendMessage(text = null) {
            let msgText = text || els.input.value.trim();
            if (!msgText) return;

            // Video Game Genre Special Handling
            if (els.genre.value === 'Video Game' && !state.videoGameContext) {
                const startChoice = prompt(
                    'üéÆ VIDEO GAME START\n\n' +
                    'Where does your character start?\n' +
                    '1. Real Life (They will enter the game later)\n' +
                    '2. In Game (They start inside the game world)\n\n' +
                    'Type "1" or "2" (or "Real" / "Game"):'
                );

                if (startChoice === null) return; // User cancelled

                const choice = startChoice.toLowerCase();
                let context = "";
                if (choice.includes('1') || choice.includes('real')) {
                    context = "The story starts in the REAL WORLD. The character is a gamer who will eventually enter the video game.";
                } else {
                    context = "The story starts directly INSIDE the video game world. The character is already in the game.";
                }

                // Prepend context to user's message
                msgText = `[Genre: Video Game] ${context} \n\nUser's opening action/request: "${msgText}"`;
                state.videoGameContext = true;
            }

            // Romance Genre Special Handling
            if (els.genre.value === 'Romance' && !state.romanceContext) {
                const disclaimer = "All characters, narrators, participants, users, observers, and any individuals represented, implied, or referenced in this system are 18 years of age or older. All interactions, scenarios, and depictions involve consenting adults only. No minors are present, mentioned, implied, or involved in any capacity. This requirement applies universally to every part of the system, all outputs, and all usage.";

                const agreed = confirm("‚ö†Ô∏è AGE VERIFICATION REQUIRED\n\n" + disclaimer + "\n\nPress OK to confirm you are 18+ and consent to these terms.");

                if (!agreed) {
                    els.genre.value = 'High Fantasy'; // Reset to default
                    return;
                }

                const theme = prompt(
                    'üíñ ROMANCE THEMES\n\n' +
                    'Choose a theme or trope to start:\n' +
                    '‚Ä¢ Slow Burn / Sweet\n' +
                    '‚Ä¢ Enemies to Lovers\n' +
                    '‚Ä¢ Secret Affair\n' +
                    '‚Ä¢ Steamy Encounter\n' +
                    '‚Ä¢ Dark Romance\n' +
                    '‚Ä¢ Forbidden Love\n\n' +
                    'Type your choice (or press Enter for random):'
                );

                if (theme === null) return; // User cancelled

                // Prepend the theme to the message to guide the bot
                msgText = `Start a Romance story with the theme: ${theme || 'Random'}. [romantic]`;
                state.romanceContext = true;
            }

            // Christian Genre Special Handling
            if (els.genre.value === 'Christian' && !state.christianContext) {
                // Only auto-switch to male voice if user hasn't manually selected a different voice
                // (if voice is still default Thorne or Silent, keep it as Thorne)
                if (els.voice.value === '' || !state.userChangedVoice) {
                    els.voice.value = 'dPah2VEoifKnZT37774q'; // Set to Thorne
                }
                // Otherwise respect user's voice choice
                const verse = prompt(
                    'üìñ BIBLE STORYTELLING\n\n' +
                    '‚ö†Ô∏è NOTE: Opening options are selected here in this popup.\n' +
                    'After that, interactions continue in the chat bar below.\n\n' +
                    'Tell me which part of the Bible you\'d like to explore:\n' +
                    '‚Ä¢ Specific verse (e.g., "John 3:16")\n' +
                    '‚Ä¢ Book or chapter (e.g., "Genesis 1", "Book of Daniel")\n' +
                    '‚Ä¢ Theme or topic (e.g., "faith", "miracles")\n' +
                    '‚Ä¢ Type anything you want!\n' +
                    '‚Ä¢ Or press Enter for a random Bible story\n\n' +
                    'Your request:'
                );

                if (verse === null) return; // User cancelled

                // Ask for length preference
                const length = prompt(
                    'üìè STORY LENGTH\n\n' +
                    'How long should the story be?\n\n' +
                    'Short - Quick summary (1-2 paragraphs)\n' +
                    'Normal - Standard retelling (3-4 paragraphs)\n\n' +
                    'Type: short or normal\n' +
                    '(Press Enter for Short)'
                );

                if (length === null) return; // User cancelled

                const selectedLength = (length.trim().toLowerCase() || 'short');
                let lengthInstruction = '';

                if (selectedLength === 'normal') {
                    lengthInstruction = ' Tell it in 3-4 paragraphs.';
                } else {
                    lengthInstruction = ' Keep it brief - just 1-2 paragraphs.';
                }

                if (verse.trim() === '' || verse.trim().toLowerCase() === 'random') {
                    // Client-side random story selector for true variety
                    const randomStories = [
                        'David and Goliath (1 Samuel 17)',
                        'Daniel in the Lion\'s Den (Daniel 6)',
                        'Jonah and the Whale (Jonah 1-4)',
                        'The Good Samaritan (Luke 10:25-37)',
                        'Noah\'s Ark (Genesis 6-9)',
                        'The Prodigal Son (Luke 15:11-32)',
                        'Moses Parting the Red Sea (Exodus 14)',
                        'The Birth of Jesus (Luke 2)',
                        'Samson and Delilah (Judges 16)',
                        'The Sermon on the Mount (Matthew 5-7)',
                        'Elijah and the Prophets of Baal (1 Kings 18)',
                        'The Fall of Jericho (Joshua 6)',
                        'Joseph and his Coat of Many Colors (Genesis 37)',
                        'Jesus Feeds the 5000 (Matthew 14)',
                        'The Raising of Lazarus (John 11)'
                    ];
                    const randomStory = randomStories[Math.floor(Math.random() * randomStories.length)];
                    msgText = `Tell me the Bible story of ${randomStory}.` + lengthInstruction;
                    state.christianContext = 'started';
                } else {
                    msgText = `Tell me the Bible story from ${verse}.` + lengthInstruction;
                    state.christianContext = 'started';
                }
            }

            // UI Updates
            els.input.value = '';
            els.input.disabled = true;
            els.sendBtn.disabled = true;
            addMessage(msgText, true);

            // Stop previous audio
            audioQueue.stop();

            // Loading
            const loader = document.createElement('div');
            loader.className = 'message bot-message';
            loader.innerHTML = '<div class="avatar">‚è≥</div><div class="message-content"><div class="magical-orb"></div></div>';
            els.messages.appendChild(loader);
            els.container.scrollTop = els.container.scrollHeight;

            try {
                const res = await fetch(`${BACKEND_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: msgText,
                        history: state.history,
                        genre: els.genre.value
                    })
                });

                loader.remove();

                if (!res.ok) {
                    const errData = await res.json().catch(() => ({}));
                    throw new Error(errData.details || errData.error || `Server Error ${res.status}`);
                }

                const data = await res.json();
                let reply = data.reply;

                // Process JSON Actions
                const lines = reply.split('\n');
                const cleanLines = lines.filter(line => {
                    if (line.trim().startsWith('{') && line.trim().endsWith('}')) {
                        try {
                            const action = JSON.parse(line);
                            if (action.action === 'add_item') state.inventory.push(action.item);
                            if (action.action === 'remove_item') {
                                state.inventory = state.inventory.filter(i => i.name !== action.item.name);
                            }
                            if (action.action === 'consume_item') {
                                state.inventory = state.inventory.filter(i => i.name !== action.item.name);
                                addMessage(`‚ú® Used ${action.item.name}`, false);
                            }
                            return false;
                        } catch (e) { return true; }
                    }
                    return true;
                });

                reply = cleanLines.join('\n').trim();
                updateInventory();

                state.lastFullText = reply;
                state.history.push({ role: 'user', parts: msgText });
                state.history.push({ role: 'model', parts: reply });

                // Display message immediately (without waiting for audio)
                addMessage(stripAudioTags(reply), false, false, null);

                // --- TTS: Fetch, cache, and enable playback/download ---
                if (els.voice.value && reply) {
                    const audioBlob = await fetchTTS(reply);
                    if (audioBlob) {
                        // Cache the audio
                        state.audioCache = audioBlob;

                        // Enable buttons
                        els.playPause.disabled = false;
                        els.downloadBtn.disabled = false;

                        // Update the last message with download button
                        const lastMessage = els.messages.lastElementChild;
                        if (lastMessage && !lastMessage.classList.contains('user-message')) {
                            const messageBody = lastMessage.querySelector('.message-body');
                            if (messageBody) {
                                const downloadContainer = document.createElement('div');
                                downloadContainer.className = 'message-download-container';

                                const downloadBtn = document.createElement('button');
                                downloadBtn.className = 'message-download-btn';
                                downloadBtn.innerHTML = 'üíæ Download Audio';
                                downloadBtn.title = 'Download Audio';
                                downloadBtn.onclick = async () => {
                                    const originalText = downloadBtn.innerHTML;
                                    downloadBtn.innerHTML = '‚è≥ Downloading...';
                                    downloadBtn.disabled = true;

                                    try {
                                        let blob;
                                        if (typeof audioBlob === 'string') {
                                            const resp = await fetch(audioBlob);
                                            if (!resp.ok) throw new Error('Download failed');
                                            blob = await resp.blob();
                                        } else {
                                            blob = audioBlob;
                                        }

                                        const url = URL.createObjectURL(blob);
                                        const a = document.createElement('a');
                                        a.href = url;
                                        a.download = `storyforge-${Date.now()}.mp3`;
                                        document.body.appendChild(a);
                                        a.click();
                                        document.body.removeChild(a);
                                        URL.revokeObjectURL(url);
                                    } catch (e) {
                                        console.error("Download error", e);
                                        alert("Failed to download audio.");
                                    } finally {
                                        downloadBtn.innerHTML = originalText;
                                        downloadBtn.disabled = false;
                                    }
                                };

                                downloadContainer.appendChild(downloadBtn);
                                messageBody.appendChild(downloadContainer);
                            }
                        }

                        // Add to queue and play
                        audioQueue.add(audioBlob);
                    }
                }

            } catch (err) {
                loader.remove();
                addMessage(`‚ö†Ô∏è Error: ${err.message}`, false, true);
            } finally {
                els.input.disabled = false;
                els.sendBtn.disabled = false;
                els.input.focus();
            }
        }

        // --- Event Listeners ---

        els.sendBtn.addEventListener('click', () => sendMessage());
        els.input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        // Track when user manually changes voice
        els.voice.addEventListener('change', () => {
            state.userChangedVoice = true;
        });

        // Play/Pause button - use cached audio, don't re-fetch
        els.playPause.addEventListener('click', () => {
            if (audioQueue.isPlaying) {
                audioQueue.pause();
            } else {
                // Use cached audio if available, don't re-fetch!
                if (state.audioCache && !audioQueue.isPlaying) {
                    audioQueue.add(state.audioCache);
                }
            }
        });

        // Download button - download the cached audio
        els.downloadBtn.addEventListener('click', () => {
            if (state.audioCache) {
                const url = URL.createObjectURL(state.audioCache);
                const a = document.createElement('a');
                a.href = url;
                a.download = `storyforge-audio-${Date.now()}.mp3`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        });

        els.itemDrop.addEventListener('change', (e) => {
            const idx = e.target.value;
            if (idx !== "") {
                const item = state.inventory[idx];
                sendMessage(`I use the ${item.name}`);
                e.target.value = "";
            }
        });

    })();
</script>
<!-- Squarespace Code Block End -->