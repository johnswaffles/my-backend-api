<!-- Squarespace Code Block Start -->
<!-- StoryForge v2.0.5 - 2025-12-02 18:00 - CHARACTER CONSISTENCY UPDATE -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400;600&display=swap"
    rel="stylesheet">
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

<div id="storyforge-app">
    <!-- Background Elements -->
    <div class="sf-bg-glow"></div>

    <!-- Header -->
    <header class="sf-header glass-panel">
        <div class="sf-brand">
            <div class="sf-logo">‚ú®</div>
            <div class="sf-title">StoryForge</div>
        </div>
        <div class="sf-controls">
            <button id="new-story-btn" class="sf-btn-new" title="Start New Story">New Story</button>
            <select id="genre-selector" class="sf-select" title="Select Genre">
                <option value="Fantasy">Fantasy</option>
                <option value="Science Fiction" selected>Science Fiction</option>
                <option value="Horror">Horror</option>
                <option value="Mystery">Mystery</option>
                <option value="Thriller">Thriller</option>
                <option value="Romance">Romance</option>
                <option value="Adventure">Adventure</option>
                <option value="Historical Fiction">Historical Fiction</option>
                <option value="Western">Western</option>
                <option value="Drama">Drama</option>
                <option value="Action">Action</option>
                <option value="Comedy">Comedy</option>
                <option value="Superhero">Superhero</option>
                <option value="Post-Apocalyptic">Post-Apocalyptic</option>
                <option value="Video Game">Video Game</option>
                <option value="Christian">Christian</option>
            </select>
            <select id="voice-selector" class="sf-select" title="Select Voice">
                <option value="" selected>Silent</option>
                <option value="alloy">Marcus</option>
                <option value="ash">Thorne</option>
                <option value="ballad">Luna</option>
                <option value="cedar">Caleb</option>
                <option value="coral">Sophia</option>
                <option value="echo">Raven</option>
                <option value="fable">Jasper</option>
                <option value="marin">Marina</option>
                <option value="nova">Aurora</option>
                <option value="onyx">Viktor</option>
                <option value="sage">Elder</option>
                <option value="shimmer">Celeste</option>
                <option value="verse">Gabriel</option>
            </select>
            <select id="art-style-selector" class="sf-select" title="Select Art Style">
                <option value="Anime">Anime</option>
                <option value="Oil Painting">Oil Painting</option>
                <option value="Watercolor">Watercolor</option>
                <option value="Digital Art">Digital Art</option>
                <option value="Concept Art">Concept Art</option>
                <option value="Comic Book" selected>Comic Book</option>
                <option value="Manga">Manga</option>
                <option value="Pixel Art">Pixel Art</option>
                <option value="Impressionism">Impressionism</option>
                <option value="Art Nouveau">Art Nouveau</option>
                <option value="Pop Art">Pop Art</option>
                <option value="Surrealism">Surrealism</option>
                <option value="Photorealistic">Photorealistic</option>
                <option value="Charcoal Sketch">Charcoal Sketch</option>
                <option value="Fantasy Art">Fantasy Art</option>
                <option value="Cyberpunk">Cyberpunk</option>
                <option value="Steampunk">Steampunk</option>
                <option value="Studio Ghibli">Ghibli Style</option>
            </select>
            <button id="gen-art-btn" class="sf-btn-icon" title="Generate Scene Art" style="display:none;">üé®</button>
            <button id="play-pause-btn" class="sf-btn-icon" disabled title="Play/Pause TTS">‚ñ∂Ô∏è</button>
            <button id="download-btn" class="sf-btn-icon" disabled title="Download Audio">üíæ</button>
        </div>
    </header>

    <!-- Main Chat Area -->
    <main id="chat-container">
        <div id="chat-messages">
            <div class="message bot-message">
                <div class="avatar">
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2L14.5 9.5L22 12L14.5 14.5L12 22L9.5 14.5L2 12L9.5 9.5L12 2Z" fill="url(#grad1)" />
                        <defs>
                            <linearGradient id="grad1" x1="2" y1="2" x2="22" y2="22" gradientUnits="userSpaceOnUse">
                                <stop stop-color="#ffd700" />
                                <stop offset="1" stop-color="#b537f2" />
                            </linearGradient>
                        </defs>
                    </svg>
                </div>
                <div class="message-content">
                    Welcome, traveler. Select a genre and voice above, then tell me how your story begins...
                </div>
            </div>
        </div>
    </main>

    <!-- Inventory Panel -->
    <div id="inventory-panel" class="glass-panel">
        <div class="panel-label">INVENTORY</div>
        <div id="inventory-grid">
            <div class="empty-slot">Empty</div>
        </div>
        <select id="item-use-dropdown" class="sf-select-sm">
            <option value="">‚öóÔ∏è Use Item</option>
        </select>
    </div>

    <!-- Input Area -->
    <footer class="sf-footer glass-panel">
        <input type="text" id="chat-input" placeholder="What do you do next?" autocomplete="off">
        <button id="send-btn" class="sf-btn-primary">SEND</button>
    </footer>
</div>

<style>
    :root {
        --bg-dark: #0f0c29;
        --bg-mid: #302b63;
        --bg-light: #24243e;
        --accent-gold: #ffd700;
        --accent-purple: #b537f2;
        --text-main: #ffffff;
        --text-muted: #a0a0a0;
        --glass-bg: rgba(20, 20, 40, 0.7);
        --glass-border: rgba(255, 255, 255, 0.1);
        --font-header: 'Cinzel', serif;
        --font-body: 'Inter', sans-serif;
    }

    /* Reset & Base */
    #storyforge-app * {
        box-sizing: border-box;
    }

    #storyforge-app {
        font-family: var(--font-body);
        background: linear-gradient(135deg, var(--bg-dark), var(--bg-mid));
        color: var(--text-main);
        width: 100%;
        max-width: 900px;
        height: 700px;
        margin: 0 auto;
        border-radius: 16px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        position: relative;
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
        border: 1px solid var(--glass-border);
    }

    /* Background Glow */
    .sf-bg-glow {
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(181, 55, 242, 0.1) 0%, transparent 60%);
        pointer-events: none;
        z-index: 0;
    }

    /* Glassmorphism Utility */
    .glass-panel {
        background: var(--glass-bg);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid var(--glass-border);
        z-index: 10;
    }

    /* Header */
    .sf-header {
        padding: 16px 24px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--glass-border);
    }

    .sf-brand {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .sf-logo {
        font-size: 1.5rem;
        animation: float 3s ease-in-out infinite;
    }

    .sf-title {
        font-family: var(--font-header);
        font-size: 1.4rem;
        font-weight: 700;
        background: linear-gradient(to right, #fff, var(--accent-gold));
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: 1px;
    }

    .sf-controls {
        display: flex;
        gap: 10px;
    }

    /* Controls */
    .sf-select {
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid var(--glass-border);
        color: var(--text-main);
        padding: 6px 12px;
        border-radius: 8px;
        font-family: var(--font-body);
        font-size: 0.85rem;
        cursor: pointer;
        transition: all 0.2s;
    }

    .sf-select:hover {
        border-color: var(--accent-purple);
    }

    .sf-btn-new {
        background: linear-gradient(135deg, #FFD700, #FFA500);
        border: none;
        color: #000;
        padding: 6px 14px;
        border-radius: 8px;
        font-family: var(--font-body);
        font-size: 0.85rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        box-shadow: 0 2px 8px rgba(255, 215, 0, 0.4);
    }

    .sf-btn-new:hover {
        background: linear-gradient(135deg, #FFE44D, #FFB733);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(255, 215, 0, 0.5);
    }

    .sf-btn-icon {
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid var(--glass-border);
        color: var(--text-main);
        width: 36px;
        height: 36px;
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s;
    }

    .sf-btn-icon:hover:not(:disabled) {
        background: var(--accent-purple);
        transform: scale(1.05);
    }

    .sf-btn-icon:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    /* Chat Area */
    #chat-container {
        flex: 1;
        overflow-y: auto;
        padding: 24px;
        position: relative;
        z-index: 5;
        scroll-behavior: smooth;
    }

    #chat-messages {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    /* Messages */
    .message {
        display: flex;
        gap: 12px;
        max-width: 85%;
        animation: fadeUp 0.4s ease-out forwards;
        opacity: 0;
        transform: translateY(10px);
    }

    .bot-message {
        align-self: flex-start;
    }

    .user-message {
        align-self: flex-end;
        flex-direction: row-reverse;
    }

    .avatar {
        width: 36px;
        height: 36px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.2rem;
        border: 1px solid var(--glass-border);
        flex-shrink: 0;
    }

    .message-content {
        padding: 14px 18px;
        border-radius: 12px;
        line-height: 1.6;
        font-size: 0.95rem;
        position: relative;
    }

    .bot-message .message-content {
        background: rgba(255, 255, 255, 0.08);
        border: 1px solid var(--glass-border);
        border-top-left-radius: 2px;
    }

    .user-message .message-content {
        background: linear-gradient(135deg, var(--accent-purple), #8a2be2);
        color: white;
        border-top-right-radius: 2px;
        box-shadow: 0 4px 15px rgba(181, 55, 242, 0.3);
    }

    .message-body {
        display: flex;
        flex-direction: column;
        flex: 1;
        min-width: 0;
        /* Prevent flex overflow */
    }

    /* Message Download Button */
    .message-download-container {
        margin-top: 8px;
        border-top: 1px solid rgba(255, 255, 255, 0.1);
        padding-top: 8px;
        display: flex;
        justify-content: flex-end;
        width: 100%;
    }

    .message-download-btn {
        background: rgba(255, 215, 0, 0.1);
        border: 1px solid var(--accent-gold);
        color: var(--accent-gold);
        padding: 8px 16px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 8px;
        transition: all 0.2s;
        white-space: nowrap;
    }

    .message-download-btn:hover {
        background: var(--accent-gold);
        color: var(--bg-dark);
    }

    /* Loading Spinner for Play Button */
    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    .spinner {
        width: 16px;
        height: 16px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-top: 2px solid white;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        display: inline-block;
    }

    /* Inventory */
    #inventory-panel {
        padding: 12px 24px;
        display: flex;
        align-items: center;
        gap: 16px;
        border-top: 1px solid var(--glass-border);
    }

    .panel-label {
        font-family: var(--font-header);
        font-size: 0.8rem;
        color: var(--accent-gold);
        letter-spacing: 1px;
    }

    #inventory-grid {
        flex: 1;
        display: flex;
        gap: 8px;
        overflow-x: auto;
        padding-bottom: 4px;
    }

    .inventory-item {
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid var(--accent-gold);
        padding: 4px 10px;
        border-radius: 4px;
        font-size: 0.8rem;
        white-space: nowrap;
        color: var(--accent-gold);
    }

    .empty-slot {
        color: var(--text-muted);
        font-style: italic;
        font-size: 0.8rem;
    }

    .sf-select-sm {
        padding: 4px 8px;
        font-size: 0.8rem;
        background: rgba(0, 0, 0, 0.4);
        border: 1px solid var(--glass-border);
        color: var(--text-main);
        border-radius: 4px;
    }

    /* Footer */
    .sf-footer {
        padding: 20px 24px;
        display: flex;
        gap: 12px;
    }

    #chat-input {
        flex: 1;
        background: rgba(0, 0, 0, 0.3);
        border: 1px solid var(--glass-border);
        padding: 14px;
        border-radius: 8px;
        color: white;
        font-family: var(--font-body);
        font-size: 1rem;
        transition: all 0.2s;
    }

    #chat-input:focus {
        outline: none;
        border-color: var(--accent-purple);
        background: rgba(0, 0, 0, 0.5);
    }

    .sf-btn-primary {
        background: var(--accent-purple);
        color: white;
        border: none;
        padding: 0 24px;
        border-radius: 8px;
        font-family: var(--font-header);
        font-weight: 700;
        cursor: pointer;
        transition: all 0.2s;
        letter-spacing: 1px;
    }

    .sf-btn-primary:hover:not(:disabled) {
        background: #d05bf5;
        box-shadow: 0 0 15px rgba(208, 91, 245, 0.4);
    }

    .sf-btn-primary:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    /* Animations */
    @keyframes fadeUp {
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    /* ========================================
       MOBILE RESPONSIVE STYLES
       ======================================== */

    @media (max-width: 768px) {

        /* App Container */
        #storyforge-app {
            height: 100vh;
            max-width: 100%;
            border-radius: 0;
            margin: 0;
        }

        /* Header - Stack controls on small screens */
        .sf-header {
            padding: 10px 12px;
            flex-direction: column;
            gap: 10px;
            align-items: stretch;
        }

        .sf-brand {
            justify-content: center;
        }

        .sf-title {
            font-size: 1.1rem;
        }

        .sf-logo {
            font-size: 1.2rem;
        }

        .sf-controls {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 6px;
            width: 100%;
        }

        .sf-select {
            font-size: 0.75rem;
            padding: 6px;
            min-width: 0;
        }

        .sf-btn-icon {
            width: 36px;
            height: 36px;
        }

        /* Chat Area - Minimal padding for max width */
        #chat-container {
            padding: 8px;
        }

        #chat-messages {
            gap: 12px;
        }

        /* Messages - Full width, no avatar on mobile */
        .message {
            max-width: 100%;
            gap: 0;
        }

        /* Hide bot avatar on mobile to save space */
        .bot-message .avatar {
            display: none;
        }

        .message-content {
            font-size: 0.95rem;
            line-height: 1.5;
            padding: 10px 12px;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .bot-message .message-content {
            border-radius: 12px;
        }

        .user-message .message-content {
            border-radius: 12px;
        }

        /* Inventory - Compact on mobile */
        #inventory-panel {
            position: relative;
            right: auto;
            bottom: auto;
            width: 100%;
            margin: 0;
            border-radius: 0;
            padding: 8px 12px;
        }

        #inventory-grid {
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 6px;
        }

        .item-slot,
        .empty-slot {
            padding: 6px;
            font-size: 0.7rem;
        }

        /* Footer - Compact input area */
        .sf-footer {
            padding: 10px 12px;
            gap: 8px;
        }

        #chat-input {
            font-size: 16px;
            /* Prevent zoom on iOS - must be 16px */
            padding: 10px;
        }

        #send-btn {
            padding: 10px 16px;
            font-size: 0.85rem;
            min-width: 70px;
            white-space: nowrap;
        }

        /* Loader - Smaller on mobile */
        .sf-loader {
            width: 36px;
            height: 36px;
        }

        /* Prevent text overflow */
        .message-content p {
            margin: 0.4em 0;
        }

        .message-content ul,
        .message-content ol {
            padding-left: 1.2em;
            margin: 0.4em 0;
        }
    }

    /* Extra small phones */
    @media (max-width: 375px) {
        .sf-title {
            font-size: 1rem;
        }

        .sf-controls {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto;
        }

        .sf-btn-icon {
            grid-column: 1 / -1;
            justify-self: center;
            width: 100%;
            max-width: 120px;
            border-radius: 8px;
        }

        .message-content {
            font-size: 0.9rem;
        }

        #send-btn {
            min-width: 70px;
            padding: 12px 16px;
        }
    }


    @keyframes float {

        0%,
        100% {
            transform: translateY(0);
        }

        50% {
            transform: translateY(-5px);
        }
    }

    @keyframes pulse-glow {
        0% {
            box-shadow: 0 0 5px var(--accent-purple);
        }

        50% {
            box-shadow: 0 0 20px var(--accent-purple), 0 0 10px var(--accent-gold);
        }

        100% {
            box-shadow: 0 0 5px var(--accent-purple);
        }
    }

    /* Magical Loader */
    .magical-orb {
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: radial-gradient(circle at 30% 30%, #fff, var(--accent-purple));
        animation: pulse-glow 1.5s infinite ease-in-out;
        margin: 0 auto;
    }

    /* Generated Image Container */
    .generated-image-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
        align-items: center;
        width: 100%;
    }

    .generated-image {
        width: 100%;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        opacity: 0;
        transition: opacity 0.5s ease-in;
    }

    .image-controls {
        display: flex;
        gap: 10px;
        width: 100%;
        justify-content: center;
    }

    .download-img-btn {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        padding: 8px 16px;
        border-radius: 20px;
        color: white;
        text-decoration: none;
        font-size: 0.9rem;
        transition: all 0.2s;
    }

    .download-img-btn:hover {
        background: rgba(255, 255, 255, 0.2);
        transform: translateY(-2px);
    }

    /* Image Generation Loader - Holographic Neural Network */
    .image-loader {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 30px 40px;
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.8) 0%, rgba(20, 20, 40, 0.9) 100%);
        border-radius: 16px;
        margin: 15px 0;
        border: 2px solid transparent;
        background-clip: padding-box;
        overflow: hidden;
    }

    .image-loader::before {
        content: '';
        position: absolute;
        inset: -2px;
        background: linear-gradient(45deg, #00f7ff, #ff00ff, #00f7ff, #ff00ff);
        background-size: 400% 400%;
        animation: gradient-spin 3s linear infinite;
        border-radius: 18px;
        z-index: -1;
    }

    .image-loader::after {
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(circle at 50% 50%, rgba(0, 247, 255, 0.1) 0%, transparent 70%);
        animation: pulse-glow 2s ease-in-out infinite;
    }

    @keyframes gradient-spin {
        0% {
            background-position: 0% 50%;
        }

        50% {
            background-position: 100% 50%;
        }

        100% {
            background-position: 0% 50%;
        }
    }

    @keyframes pulse-glow {

        0%,
        100% {
            opacity: 0.3;
            transform: scale(1);
        }

        50% {
            opacity: 0.8;
            transform: scale(1.05);
        }
    }

    /* Neural Network Orb */
    .neural-orb {
        position: relative;
        width: 80px;
        height: 80px;
        margin-bottom: 15px;
    }

    .neural-orb::before {
        content: '';
        position: absolute;
        inset: 0;
        border-radius: 50%;
        background: conic-gradient(from 0deg, #00f7ff, #ff00ff, #00ff88, #ff00ff, #00f7ff);
        animation: orb-spin 2s linear infinite;
        filter: blur(2px);
    }

    .neural-orb::after {
        content: 'üé®';
        position: absolute;
        inset: 8px;
        background: radial-gradient(circle, #1a1a2e 0%, #0f0f1a 100%);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 28px;
        animation: orb-pulse 1.5s ease-in-out infinite;
    }

    @keyframes orb-spin {
        from {
            transform: rotate(0deg);
        }

        to {
            transform: rotate(360deg);
        }
    }

    @keyframes orb-pulse {

        0%,
        100% {
            transform: scale(1);
        }

        50% {
            transform: scale(1.1);
        }
    }

    /* Floating particles */
    .loader-particles {
        position: absolute;
        width: 100%;
        height: 100%;
        overflow: hidden;
    }

    .loader-particles span {
        position: absolute;
        width: 4px;
        height: 4px;
        background: #00f7ff;
        border-radius: 50%;
        animation: float-up 3s ease-in-out infinite;
        box-shadow: 0 0 10px #00f7ff;
    }

    .loader-particles span:nth-child(1) {
        left: 10%;
        animation-delay: 0s;
    }

    .loader-particles span:nth-child(2) {
        left: 30%;
        animation-delay: 0.5s;
        background: #ff00ff;
        box-shadow: 0 0 10px #ff00ff;
    }

    .loader-particles span:nth-child(3) {
        left: 50%;
        animation-delay: 1s;
    }

    .loader-particles span:nth-child(4) {
        left: 70%;
        animation-delay: 1.5s;
        background: #00ff88;
        box-shadow: 0 0 10px #00ff88;
    }

    .loader-particles span:nth-child(5) {
        left: 90%;
        animation-delay: 2s;
        background: #ff00ff;
        box-shadow: 0 0 10px #ff00ff;
    }

    @keyframes float-up {
        0% {
            bottom: -10px;
            opacity: 0;
        }

        20% {
            opacity: 1;
        }

        80% {
            opacity: 1;
        }

        100% {
            bottom: 100%;
            opacity: 0;
        }
    }

    .loader-text {
        font-family: 'Orbitron', sans-serif;
        font-size: 0.9em;
        color: #fff;
        text-transform: uppercase;
        letter-spacing: 3px;
        text-shadow: 0 0 20px #00f7ff, 0 0 40px #ff00ff;
        animation: text-flicker 2s ease-in-out infinite;
        z-index: 1;
    }

    @keyframes text-flicker {

        0%,
        100% {
            opacity: 1;
        }

        50% {
            opacity: 0.8;
        }

        52% {
            opacity: 1;
        }

        54% {
            opacity: 0.9;
        }
    }

    .loader-subtext {
        font-family: 'Inter', sans-serif;
        font-size: 0.75em;
        color: rgba(255, 255, 255, 0.6);
        margin-top: 8px;
        z-index: 1;
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
    }

    ::-webkit-scrollbar-track {
        background: transparent;
    }

    ::-webkit-scrollbar-thumb {
        background: rgba(255, 255, 255, 0.2);
        border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
        background: rgba(255, 255, 255, 0.4);
    }

    /* Mobile */
    @media (max-width: 600px) {
        #storyforge-app {
            height: 100vh;
            border-radius: 0;
        }

        .sf-title {
            display: none;
        }
    }
</style>

<script>
    console.log('‚úÖ StoryForge Script Starting - Version 2.0');
    (function () {
        'use strict';
        if (window.storyForgeInitialized) return;
        window.storyForgeInitialized = true;

        const BACKEND_URL = 'https://my-backend-api-1niy.onrender.com';

        // --- Audio Queue System ---
        class AudioQueue {
            constructor() {
                this.queue = [];
                this.isPlaying = false;
                this.currentAudio = null;
            }

            add(item) {
                this.queue.push(item);
                if (!this.isPlaying) this.playNext();
            }

            playNext() {
                if (this.queue.length === 0) {
                    this.isPlaying = false;
                    updatePlayButton(false);
                    return;
                }

                this.isPlaying = true;
                const item = this.queue.shift();

                let url;
                if (typeof item === 'string') {
                    url = item; // It's a URL
                } else {
                    url = URL.createObjectURL(item); // It's a Blob
                }

                this.currentAudio = new Audio();
                this.currentAudio.crossOrigin = "anonymous"; // Re-added for reliable CORS handling
                this.currentAudio.src = url;
                this.currentAudio.preload = "auto";

                this.currentAudio.preload = "auto";

                updatePlayButton('loading');

                this.currentAudio.onwaiting = () => updatePlayButton('loading');
                this.currentAudio.onplaying = () => updatePlayButton('playing');
                this.currentAudio.onpause = () => updatePlayButton('paused');

                this.currentAudio.onended = () => {
                    if (typeof item !== 'string') URL.revokeObjectURL(url); // Clean up blob URLs
                    this.playNext();
                };

                this.currentAudio.onerror = (e) => {
                    console.error("Audio Playback Error", e);
                    addMessage(`‚ö†Ô∏è Playback Error: ${e.type}`, false, true);
                    if (typeof item !== 'string') URL.revokeObjectURL(url);
                    this.playNext();
                };

                // Attempt to play
                const playPromise = this.currentAudio.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.error("Playback failed", error);
                        // Auto-play might be blocked. Show a "Click to Play" message or just stop.
                        // But since user clicked "Send", it should work.
                        // Unless the async fetch took too long?
                        updatePlayButton(false);
                    });
                }
            }

            stop() {
                if (this.currentAudio) {
                    this.currentAudio.pause();
                    this.currentAudio = null;
                }
                this.queue = [];
                this.isPlaying = false;
                updatePlayButton(false);
            }

            pause() {
                if (this.currentAudio) {
                    this.currentAudio.pause();
                }
                this.isPlaying = false;
                updatePlayButton(false);
            }
        }

        const audioQueue = new AudioQueue();

        // --- State & DOM ---
        const state = {
            inventory: [],
            history: [],
            lastFullText: '',
            christianContext: false,
            romanceContext: null,
            videoGameContext: false,
            audioCache: null,  // Cache audio to prevent duplicate API calls
            characterCard: null,  // Stores detailed character description for image consistency
            userChangedVoice: false,  // Track if user manually changed voice
            isGeneratingImage: false,
            isSending: false,  // Debounce lock for sendMessage
            currentImage: '',
            lastGeneratedImage: null,  // Store last image for reference in next generation
            turnCount: 0 // Track number of turns for auto-image generation
        };

        const els = {
            input: document.getElementById('chat-input'),
            sendBtn: document.getElementById('send-btn'),
            messages: document.getElementById('chat-messages'),
            genre: document.getElementById('genre-selector'),
            voice: document.getElementById('voice-selector'),
            playPause: document.getElementById('play-pause-btn'),
            downloadBtn: document.getElementById('download-btn'),
            artStyle: document.getElementById('art-style-selector'),
            genArtBtn: document.getElementById('gen-art-btn'),
            invGrid: document.getElementById('inventory-grid'),
            itemDrop: document.getElementById('item-use-dropdown'),
            container: document.getElementById('chat-container'),
            newStoryBtn: document.getElementById('new-story-btn')
        };

        // --- Helpers ---

        function stripAudioTags(text) {
            // Remove all audio tags like [whispers], [laughs], [pause], etc.
            return text.replace(/\[([a-z_]+)\]/gi, '');
        }

        function updatePlayButton(state) {
            // Backward compatibility for boolean
            if (typeof state === 'boolean') {
                state = state ? 'playing' : 'paused';
            }

            if (state === 'loading') {
                els.playPause.innerHTML = '<div class="spinner"></div>';
                els.playPause.title = "Buffering...";
            } else if (state === 'playing') {
                els.playPause.innerHTML = '‚è∏Ô∏è';
                els.playPause.title = "Pause";
            } else {
                els.playPause.innerHTML = '‚ñ∂Ô∏è';
                els.playPause.title = "Play";
            }
        }

        function splitText(text) {
            // Split into [First Chunk, Rest]
            // Goal: Grab first ~50 words or ~300 chars to ensure audio buffer is long enough
            // Look for punctuation after 250 chars
            if (text.length < 300) {
                return { first: text, rest: '' };
            }

            const splitIdx = text.indexOf('.', 250);
            if (splitIdx !== -1) {
                return {
                    first: text.substring(0, splitIdx + 1),
                    rest: text.substring(splitIdx + 1)
                };
            }

            // Fallback if no punctuation found reasonably early
            return { first: text, rest: '' };
        }

        async function fetchTTS(text) {
            try {
                // Clean text for TTS: remove *actions*, _italics_, emojis, and JSON objects
                // This prevents the voice from reading "smiles" or "open brace action..."
                const cleanText = text
                    .replace(/\*[^*]+\*/g, '') // Remove *text*
                    .replace(/_([^_]+)_/g, '$1') // Remove _italic_ markers but keep the text
                    .replace(/\{.*?\}/g, '')   // Remove {JSON} objects (fix for jibberish)
                    .replace(/[\u{1F600}-\u{1F64F}\u{1F300}-\u{1F5FF}\u{1F680}-\u{1F6FF}\u{1F1E0}-\u{1F1FF}]/gu, '') // Remove emojis
                    .trim();

                if (!cleanText) return null; // Nothing to say

                // Show loading spinner on play button
                const originalBtnContent = els.playPause.innerHTML;
                els.playPause.innerHTML = '<div class="spinner"></div>';
                els.playPause.disabled = true;

                // Optimization: Use GET endpoint for streaming if text is short enough
                // This allows the browser to stream the audio directly via Audio element
                // Increased limit to 4000 chars to cover most stories
                if (cleanText.length < 4000) {
                    const url = `${BACKEND_URL}/tts?text=${encodeURIComponent(cleanText)}&voice=${els.voice.value}`;

                    // Restore button content immediately as we return the URL
                    els.playPause.innerHTML = originalBtnContent;
                    return url;
                }

                // Fallback to POST for long text (waits for full download)
                const response = await fetch(`${BACKEND_URL}/tts`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: cleanText,
                        voice: els.voice.value
                    })
                });

                // Restore button content
                els.playPause.innerHTML = originalBtnContent;

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`ElevenLabs API Error: ${response.status} ${JSON.stringify(errorData)}`);
                }

                const blob = await response.blob();
                return blob;
            } catch (error) {
                console.error('TTS Fetch Error:', error);
                addMessage(`‚ö†Ô∏è TTS Error: ${error.message}`, false, true);
                els.playPause.innerHTML = '‚ñ∂Ô∏è'; // Restore play icon on error
                els.playPause.disabled = true;
                return null;
            }
        }

        // --- UI Functions ---

        function addMessage(text, isUser, isError = false, audioBlob = null) {
            const div = document.createElement('div');
            div.className = `message ${isUser ? 'user-message' : 'bot-message'}`;

            // Avatar
            if (!isUser) {
                const avatar = document.createElement('div');
                avatar.className = 'avatar';
                if (isError) {
                    avatar.textContent = '‚ö†Ô∏è';
                } else {
                    // Cool SVG Graphic (Sparkle/Star)
                    avatar.innerHTML = `
                    <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2L14.5 9.5L22 12L14.5 14.5L12 22L9.5 14.5L2 12L9.5 9.5L12 2Z" fill="url(#grad1)"/>
                        <defs>
                            <linearGradient id="grad1" x1="2" y1="2" x2="22" y2="22" gradientUnits="userSpaceOnUse">
                                <stop stop-color="#ffd700"/>
                                <stop offset="1" stop-color="#b537f2"/>
                            </linearGradient>
                        </defs>
                    </svg>`;
                }
                div.appendChild(avatar);
            }

            // Message Body Wrapper (Text + Download Button)
            const messageBody = document.createElement('div');
            messageBody.className = 'message-body';

            const content = document.createElement('div');
            content.className = 'message-content';

            if (isUser || isError) {
                content.textContent = text;
            } else {
                content.innerHTML = marked.parse(text);
            }

            messageBody.appendChild(content);

            // Add download button for bot messages with audio
            if (!isUser && !isError && audioBlob) {
                const downloadContainer = document.createElement('div');
                downloadContainer.className = 'message-download-container';

                const downloadBtn = document.createElement('button');
                downloadBtn.className = 'message-download-btn';
                downloadBtn.innerHTML = 'üíæ Download Audio';
                downloadBtn.title = 'Download Audio';
                downloadBtn.onclick = async () => {
                    const originalText = downloadBtn.innerHTML;
                    downloadBtn.innerHTML = '‚è≥ Downloading...';
                    downloadBtn.disabled = true;

                    try {
                        let blob;
                        if (typeof audioBlob === 'string') {
                            const resp = await fetch(audioBlob);
                            if (!resp.ok) throw new Error('Download failed');
                            blob = await resp.blob();
                        } else {
                            blob = audioBlob;
                        }

                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `storyforge-${Date.now()}.mp3`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } catch (e) {
                        console.error("Download error", e);
                        alert("Failed to download audio.");
                    } finally {
                        downloadBtn.innerHTML = originalText;
                        downloadBtn.disabled = false;
                    }
                };

                downloadContainer.appendChild(downloadBtn);
                messageBody.appendChild(downloadContainer);
            }

            div.appendChild(messageBody);
            els.messages.appendChild(div);

            // Scroll
            setTimeout(() => {
                els.container.scrollTop = els.container.scrollHeight;
            }, 50);
        }

        function updateInventory() {
            // Hide inventory for Christian genre
            if (els.genre.value === 'Christian') {
                els.invGrid.innerHTML = '<div class="empty-slot">Inventory disabled in this mode</div>';
                els.itemDrop.innerHTML = '<option value="">‚öóÔ∏è Inventory Disabled</option>';
                els.itemDrop.disabled = true;
                return;
            }

            els.itemDrop.disabled = false;

            if (state.inventory.length === 0) {
                els.invGrid.innerHTML = '<div class="empty-slot">Empty</div>';
                els.itemDrop.innerHTML = '<option value="">‚öóÔ∏è Use Item</option>';
                return;
            }

            els.invGrid.innerHTML = state.inventory.map(item =>
                `<div class="inventory-item" title="${item.description || ''}">${item.name}</div>`
            ).join('');

            els.itemDrop.innerHTML = '<option value="">‚öóÔ∏è Use Item</option>';
            state.inventory.forEach((item, idx) => {
                const opt = document.createElement('option');
                opt.value = idx;
                opt.textContent = `Use ${item.name}`;
                els.itemDrop.appendChild(opt);
            });
        }

        // --- Core Logic ---

        // Function to parse and apply actions from bot reply
        function parseAndApplyActions(replyText) {
            const lines = replyText.split('\n');
            const cleanLines = lines.filter(line => {
                if (line.trim().startsWith('{') && line.trim().endsWith('}')) {
                    try {
                        const action = JSON.parse(line);
                        if (action.action === 'add_item') {
                            // Prevent duplicates - check if item already exists
                            const exists = state.inventory.some(i => i.name.toLowerCase() === action.item.name.toLowerCase());
                            if (!exists) {
                                state.inventory.push(action.item);
                            } else {
                                console.log('‚è≠Ô∏è Skipping duplicate item:', action.item.name);
                            }
                        }
                        if (action.action === 'remove_item') {
                            state.inventory = state.inventory.filter(i => i.name !== action.item.name);
                        }
                        if (action.action === 'consume_item') {
                            state.inventory = state.inventory.filter(i => i.name !== action.item.name);
                            addMessage(`‚ú® Used ${action.item.name}`, false);
                        }
                        return false; // This line was an action, so filter it out of the display text
                    } catch (e) {
                        console.warn("Failed to parse action JSON:", line, e);
                        return true; // Keep line if it looks like JSON but fails to parse
                    }
                }
                return true; // Keep non-JSON lines
            });
            updateInventory(); // Update inventory after processing actions
            return cleanLines.join('\n').trim(); // Return the text without action lines
        }



        async function sendMessage(text = null) {
            // Debounce: prevent duplicate calls while processing
            if (state.isSending) return;

            let msgText = text || els.input.value.trim();
            if (!msgText) return;

            state.isSending = true; // Lock

            // Video Game Genre Special Handling
            if (els.genre.value === 'Video Game' && !state.videoGameContext) {
                const startChoice = prompt(
                    'üéÆ VIDEO GAME START\n\n' +
                    'Where does your character start?\n' +
                    '1. Real Life (They will enter the game later)\n' +
                    '2. In Game (They start inside the game world)\n\n' +
                    'Type "1" or "2" (or "Real" / "Game"):'
                );

                if (startChoice === null) return; // User cancelled

                const choice = startChoice.toLowerCase();
                let context = "";
                if (choice.includes('1') || choice.includes('real')) {
                    context = "The story starts in the REAL WORLD. The character is a gamer who will eventually enter the video game.";
                } else {
                    context = "The story starts directly INSIDE the video game world. The character is already in the game.";
                }

                // Prepend context to user's message
                msgText = `[Genre: Video Game] ${context} \n\nUser's opening action/request: "${msgText}"`;
                state.videoGameContext = true;
            }

            // Romance Genre Special Handling
            if (els.genre.value === 'Romance' && !state.romanceContext) {
                const disclaimer = "All characters, narrators, participants, users, observers, and any individuals represented, implied, or referenced in this system are 18 years of age or older. All interactions, scenarios, and depictions involve consenting adults only. No minors are present, mentioned, implied, or involved in any capacity. This requirement applies universally to every part of the system, all outputs, and all usage.";

                const agreed = confirm("‚ö†Ô∏è AGE VERIFICATION REQUIRED\n\n" + disclaimer + "\n\nPress OK to confirm you are 18+ and consent to these terms.");

                if (!agreed) {
                    els.genre.value = 'High Fantasy'; // Reset to default
                    return;
                }

                const theme = prompt(
                    'üíñ ROMANCE THEMES\n\n' +
                    'Choose a theme or trope to start:\n' +
                    '‚Ä¢ Slow Burn / Sweet\n' +
                    '‚Ä¢ Enemies to Lovers\n' +
                    '‚Ä¢ Secret Affair\n' +
                    '‚Ä¢ Steamy Encounter\n' +
                    '‚Ä¢ Dark Romance\n' +
                    '‚Ä¢ Forbidden Love\n\n' +
                    'Type your choice (or press Enter for random):'
                );

                if (theme === null) return; // User cancelled

                // Prepend the theme to the message to guide the bot
                msgText = `Start a Romance story with the theme: ${theme || 'Random'}. [romantic]`;
                state.romanceContext = true;
            }

            // Christian Genre Special Handling
            if (els.genre.value === 'Christian' && !state.christianContext) {
                // Set to silent by default for Christian genre
                if (!state.userChangedVoice) {
                    els.voice.value = ''; // Silent
                }
                // Otherwise respect user's voice choice
                const verse = prompt(
                    'üìñ BIBLE STORYTELLING\n\n' +
                    '‚ö†Ô∏è NOTE: Opening options are selected here in this popup.\n' +
                    'After that, interactions continue in the chat bar below.\n\n' +
                    'Tell me which part of the Bible you\'d like to explore:\n' +
                    '‚Ä¢ Specific verse (e.g., "John 3:16")\n' +
                    '‚Ä¢ Book or chapter (e.g., "Genesis 1", "Book of Daniel")\n' +
                    '‚Ä¢ Theme or topic (e.g., "faith", "miracles")\n' +
                    '‚Ä¢ Type anything you want!\n' +
                    '‚Ä¢ Or press Enter for a random Bible story\n\n' +
                    'Your request:'
                );

                if (verse === null) return; // User cancelled

                // Ask for length preference
                const length = prompt(
                    'üìè STORY LENGTH\n\n' +
                    'How long should the story be?\n\n' +
                    'Short - Quick summary (1-2 paragraphs)\n' +
                    'Normal - Standard retelling (3-4 paragraphs)\n\n' +
                    'Type: short or normal\n' +
                    '(Press Enter for Short)'
                );

                if (length === null) return; // User cancelled

                const selectedLength = (length.trim().toLowerCase() || 'short');
                let lengthInstruction = '';

                if (selectedLength === 'normal') {
                    lengthInstruction = ' Tell it in 3-4 paragraphs.';
                } else {
                    lengthInstruction = ' Keep it brief - just 1-2 paragraphs.';
                }

                if (verse.trim() === '' || verse.trim().toLowerCase() === 'random') {
                    // Client-side random story selector for true variety
                    const randomStories = [
                        'David and Goliath (1 Samuel 17)',
                        'Daniel in the Lion\'s Den (Daniel 6)',
                        'Jonah and the Whale (Jonah 1-4)',
                        'The Good Samaritan (Luke 10:25-37)',
                        'Noah\'s Ark (Genesis 6-9)',
                        'The Prodigal Son (Luke 15:11-32)',
                        'Moses Parting the Red Sea (Exodus 14)',
                        'The Birth of Jesus (Luke 2)',
                        'Samson and Delilah (Judges 16)',
                        'The Sermon on the Mount (Matthew 5-7)',
                        'Elijah and the Prophets of Baal (1 Kings 18)',
                        'The Fall of Jericho (Joshua 6)',
                        'Joseph and his Coat of Many Colors (Genesis 37)',
                        'Jesus Feeds the 5000 (Matthew 14)',
                        'The Raising of Lazarus (John 11)'
                    ];
                    const randomStory = randomStories[Math.floor(Math.random() * randomStories.length)];
                    msgText = `Tell me the Bible story of ${randomStory}.` + lengthInstruction;
                    state.christianContext = 'started';
                    els.input.placeholder = 'Type bible verse or topic and press enter';
                } else {
                    msgText = `Tell me the Bible story from ${verse}.` + lengthInstruction;
                    state.christianContext = 'started';
                    els.input.placeholder = 'Type bible verse or topic and press enter';
                }
            }

            // UI Updates
            els.input.value = '';
            els.input.disabled = true;
            els.sendBtn.disabled = true;
            addMessage(msgText, true);

            // Stop previous audio
            audioQueue.stop();

            // Loading
            const loader = document.createElement('div');
            loader.className = 'message bot-message';
            loader.innerHTML = '<div class="avatar">‚è≥</div><div class="message-content"><div class="magical-orb"></div></div>';
            els.messages.appendChild(loader);
            els.container.scrollTop = els.container.scrollHeight;

            try {
                const res = await fetch(`${BACKEND_URL}/chat`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        message: msgText,
                        history: state.history,
                        genre: els.genre.value
                    })
                });

                loader.remove();

                if (!res.ok) {
                    const errData = await res.json().catch(() => ({}));
                    throw new Error(errData.details || errData.error || `Server Error ${res.status}`);
                }

                const data = await res.json();
                const botReply = data.reply;

                // Store character card if returned (first message)
                if (data.characterCard) {
                    state.characterCard = data.characterCard;
                    console.log('üìã Character Card Created:', state.characterCard);
                }

                let reply = botReply;

                console.log('üîç RAW REPLY FROM BACKEND:');
                console.log(reply);

                // Process JSON Actions line-by-line ONLY (backend outputs JSON on separate lines)
                const lines = reply.split('\n');
                const cleanLines = [];

                for (const line of lines) {
                    const trimmed = line.trim();

                    // Check if line looks like JSON (starts with { and contains "action")
                    if (trimmed.startsWith('{') && trimmed.includes('"action"')) {
                        try {
                            // Try to parse it
                            const action = JSON.parse(trimmed);

                            // Successfully parsed - check if it's a valid action
                            if (action && action.action) {
                                console.log('‚úÖ Line JSON parsed:', action);

                                if (action.action === 'add_item' && action.item && action.item.name) {
                                    // Prevent duplicates - check if item already exists
                                    const exists = state.inventory.some(i => i.name.toLowerCase() === action.item.name.toLowerCase());
                                    if (!exists) {
                                        state.inventory.push(action.item);
                                        console.log('‚úÖ Added item:', action.item.name);
                                    } else {
                                        console.log('‚è≠Ô∏è Skipping duplicate item:', action.item.name);
                                    }
                                } else if (action.action === 'remove_item' && action.item && action.item.name) {
                                    state.inventory = state.inventory.filter(i => i.name !== action.item.name);
                                    console.log('‚ùå Removed item:', action.item.name);
                                } else if (action.action === 'consume_item' && action.item && action.item.name) {
                                    state.inventory = state.inventory.filter(i => i.name !== action.item.name);
                                    addMessage(`‚ú® Used ${action.item.name}`, false);
                                    console.log('‚ö° Consumed item:', action.item.name);
                                }
                                // Don't add to cleanLines - this was a JSON action
                                continue;
                            }
                        } catch (e) {
                            // JSON parsing failed
                            console.warn('‚ö†Ô∏è Failed to parse line as JSON:', trimmed);
                            console.warn('Parse error:', e.message);
                        }
                    }

                    // Not JSON or parsing failed - keep the line
                    cleanLines.push(line);
                }

                reply = cleanLines.join('\n').trim();

                // Format numbered lists to ensure they're on new lines
                reply = reply.replace(/(\d+)\.\s+/g, '\n$1. ');
                reply = reply.trim();

                console.log(`üì¶ Final inventory count: ${state.inventory.length}`);

                updateInventory();

                state.lastFullText = reply;
                state.history.push({ role: 'user', parts: msgText });
                state.history.push({ role: 'model', parts: reply });

                // Display message immediately (without waiting for audio)
                addMessage(stripAudioTags(reply), false, false, null);

                // --- TTS: Fetch, cache, and enable playback/download ---
                if (els.voice.value && reply) {
                    const audioBlob = await fetchTTS(reply);
                    if (audioBlob) {
                        // Cache the audio
                        state.audioCache = audioBlob;

                        // Enable buttons
                        els.playPause.disabled = false;
                        els.downloadBtn.disabled = false;

                        // Update the last message with download button
                        const lastMessage = els.messages.lastElementChild;
                        if (lastMessage && !lastMessage.classList.contains('user-message')) {
                            const messageBody = lastMessage.querySelector('.message-body');
                            if (messageBody) {
                                const downloadContainer = document.createElement('div');
                                downloadContainer.className = 'message-download-container';

                                const downloadBtn = document.createElement('button');
                                downloadBtn.className = 'message-download-btn';
                                downloadBtn.innerHTML = 'üíæ Download Audio';
                                downloadBtn.title = 'Download Audio';
                                downloadBtn.onclick = async () => {
                                    const originalText = downloadBtn.innerHTML;
                                    downloadBtn.innerHTML = '‚è≥ Downloading...';
                                    downloadBtn.disabled = true;

                                    try {
                                        let blob;
                                        if (typeof audioBlob === 'string') {
                                            const resp = await fetch(audioBlob);
                                            if (!resp.ok) throw new Error('Download failed');
                                            blob = await resp.blob();
                                        } else {
                                            blob = audioBlob;
                                        }

                                        const url = URL.createObjectURL(blob);
                                        const a = document.createElement('a');
                                        a.href = url;
                                        a.download = `storyforge-${Date.now()}.mp3`;
                                        document.body.appendChild(a);
                                        a.click();
                                        document.body.removeChild(a);
                                        URL.revokeObjectURL(url);
                                    } catch (e) {
                                        console.error("Download error", e);
                                        alert("Failed to download audio.");
                                    } finally {
                                        downloadBtn.innerHTML = originalText;
                                        downloadBtn.disabled = false;
                                    }
                                };

                                downloadContainer.appendChild(downloadBtn);
                                messageBody.appendChild(downloadContainer);
                            }
                        }

                        // Add to queue and play
                        audioQueue.add(audioBlob);
                    }
                }

            } catch (err) {
                loader.remove();
                addMessage(`‚ö†Ô∏è Error: ${err.message}`, false, true);
            } finally {
                state.isSending = false; // Release debounce lock
                els.input.disabled = false;
                els.sendBtn.disabled = false;
                els.input.focus();

                // Auto-generate image every 4th turn (skip Christian genre - no art)
                if (els.genre.value !== 'Christian') {
                    state.turnCount++;
                    console.log(`Turn count: ${state.turnCount}`);

                    if (state.turnCount > 0 && state.turnCount % 4 === 0) {
                        console.log('üé® Auto-generating image (4th turn)');
                        setTimeout(() => generateImageAuto(), 500);
                    }
                }
            }
        }

        // --- Event Listeners ---

        els.sendBtn.addEventListener('click', () => sendMessage());
        els.input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        // Track when user manually changes voice
        els.voice.addEventListener('change', () => {
            state.userChangedVoice = true;
        });

        // Update placeholder based on genre selection
        els.genre.addEventListener('change', () => {
            const genre = els.genre.value;
            if (genre === 'Christian' || genre === 'Romance') {
                els.input.placeholder = 'Press any key, then Enter (options appear in popup)';
            } else {
                els.input.placeholder = 'What do you do next?';
            }
        });

        // Play/Pause button - use cached audio, don't re-fetch
        els.playPause.addEventListener('click', () => {
            if (audioQueue.isPlaying) {
                audioQueue.pause();
            } else {
                // Use cached audio if available, don't re-fetch!
                if (state.audioCache && !audioQueue.isPlaying) {
                    audioQueue.add(state.audioCache);
                }
            }
        });

        // New Story button - reset chat
        els.newStoryBtn.addEventListener('click', () => {
            if (confirm('Start a new story? This will clear the current chat.')) {
                // Clear chat messages
                els.messages.innerHTML = '';
                // Reset state
                state.history = [];
                state.inventory = [];
                state.turnCount = 0;
                state.characterCard = null;
                state.romanceContext = false;
                state.christianContext = false;
                state.videoGameContext = false;
                state.userChangedVoice = false;
                state.audioCache = null;
                state.lastImageUrl = null;
                // Reset voice to silent
                els.voice.value = '';
                // Reset placeholder
                els.input.placeholder = 'What do you do next?';
                // Stop any audio
                audioQueue.stop();
                // Update inventory display
                updateInventory();
                // Hide scene image
                const scenePanel = document.getElementById('scene-image-panel');
                if (scenePanel) scenePanel.style.display = 'none';
            }
        });

        // Auto Image Generation Function with retry and scene context
        async function generateImageAuto(retryCount = 0) {
            // Prevent stacked generation calls
            if (state.isGeneratingImage) {
                console.log('‚ö†Ô∏è Image generation already in progress, skipping');
                return;
            }
            state.isGeneratingImage = true;

            const maxRetries = 3;

            // Create holographic loader
            const loaderDiv = document.createElement('div');
            loaderDiv.className = 'message bot-message';
            loaderDiv.innerHTML = `
                <div class="image-loader">
                    <div class="loader-particles">
                        <span></span><span></span><span></span><span></span><span></span>
                    </div>
                    <div class="neural-orb"></div>
                    <div class="loader-text">Generating Scene</div>
                    <div class="loader-subtext">Analyzing character & environment...</div>
                </div>
            `;
            els.messages.appendChild(loaderDiv);
            els.container.scrollTop = els.container.scrollHeight;

            // Extract current scene context from last bot message
            let sceneContext = '';
            if (state.history.length > 0) {
                const lastBotMessage = [...state.history].reverse().find(m => m.role === 'model');
                if (lastBotMessage && lastBotMessage.parts) {
                    // Get first 300 chars of last bot response for scene context
                    sceneContext = String(lastBotMessage.parts).substring(0, 300);
                    console.log('üé¨ Scene context extracted:', sceneContext.substring(0, 100) + '...');
                }
            }

            try {
                // Only send last message, not full history (optimization)
                const lastMessage = state.history.length > 0 ? state.history[state.history.length - 1] : null;

                const response = await fetch(`${BACKEND_URL}/generate-image`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        lastMessage: lastMessage,  // Only last message needed
                        style: els.artStyle.value,
                        genre: els.genre.value,
                        characterCard: state.characterCard,
                        lastImageUrl: state.lastGeneratedImage,
                        sceneContext: sceneContext
                    })
                });

                // Handle 503 (overloaded) with retry
                if (response.status === 503) {
                    if (retryCount < maxRetries) {
                        console.log(`‚ö†Ô∏è Model overloaded, retrying in ${(retryCount + 1) * 2} seconds... (${retryCount + 1}/${maxRetries})`);
                        loaderDiv.querySelector('.loader-subtext').textContent = `Server busy, retrying (${retryCount + 1}/${maxRetries})...`;
                        await new Promise(r => setTimeout(r, (retryCount + 1) * 2000));
                        loaderDiv.remove();
                        return generateImageAuto(retryCount + 1);
                    }
                    throw new Error('Model is overloaded. Please try again in a few minutes.');
                }

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Image generation failed:', response.status, errorText);
                    throw new Error(`Failed to generate image: ${response.status}`);
                }

                const data = await response.json();
                console.log('Image generation response:', data);

                // Remove loader
                loaderDiv.remove();

                if (data.imageUrl) {
                    displayGeneratedImage(data.imageUrl);
                } else {
                    throw new Error('No image URL in response');
                }

            } catch (e) {
                console.error("Image Gen Error", e);
                loaderDiv.remove();

                // Friendly error in chat
                const errorDiv = document.createElement('div');
                errorDiv.className = 'message bot-message';
                errorDiv.innerHTML = `<div style="color: #ff6b6b; padding: 10px; border-left: 3px solid #ff6b6b;">‚ö†Ô∏è ${e.message.includes('overloaded') ? 'AI is busy right now. Image will generate on next turn!' : 'Image generation paused. Story continues...'}</div>`;
                els.messages.appendChild(errorDiv);
                els.container.scrollTop = els.container.scrollHeight;
            } finally {
                state.isGeneratingImage = false; // Release lock
            }
        }

        // Manual button (hidden, kept for backwards compatibility)
        els.genArtBtn.addEventListener('click', async () => {
            if (els.genArtBtn.disabled) return;
            await generateImageAuto();
        });

        function displayGeneratedImage(url) {
            const div = document.createElement('div');
            div.className = 'message bot-message image-message';
            div.innerHTML = `
                <div class="generated-image-container">
                    <img src="${url}" alt="Generated Scene" class="generated-image" onload="this.style.opacity=1">
                    <div class="image-controls">
                        <a href="${url}" download="storyforge-scene.png" target="_blank" class="download-img-btn">‚¨áÔ∏è Download Art</a>
                    </div>
                </div>
            `;
            els.messages.appendChild(div);

            // Store image for next generation reference
            state.lastGeneratedImage = url;
            console.log('‚úÖ Stored image for next reference');

            // Scroll
            setTimeout(() => {
                els.container.scrollTop = els.container.scrollHeight;
            }, 50);
        }

        // Download button - download the cached audio
        els.downloadBtn.addEventListener('click', () => {
            if (state.audioCache) {
                const url = URL.createObjectURL(state.audioCache);
                const a = document.createElement('a');
                a.href = url;
                a.download = `storyforge-audio-${Date.now()}.mp3`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        });

        els.itemDrop.addEventListener('change', (e) => {
            const idx = e.target.value;
            if (idx !== "") {
                const item = state.inventory[idx];
                sendMessage(`I use the ${item.name}`);
                e.target.value = "";
            }
        });

    })();
</script>
<!-- Squarespace Code Block End -->